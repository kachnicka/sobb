#version 460

#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2: require
#extension GL_EXT_scalar_block_layout: require
#extension GL_KHR_shader_subgroup_ballot : require

#define INCLUDE_FROM_SHADER
#include "shared/types.glsl"
#include "shared/random.glsl"
#include "shared/compute.glsl"
#include "shared/rt_common.glsl"

#include "shared/data_bvh.h"
#include "shared/data_ptrace.h"
#include "shared/data_scene.h"

layout(set = 0, binding = 0, rgba32f) uniform image2D image;
layout(set = 0, binding = 1) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 viewInv;
    mat4 projectionInv;
} camera;

layout(push_constant, scalar) uniform uPushConstant
{
    PC_ShadeCast data;
} pc;

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

struct RayInfo {
    RayBufferMetadata_ref rayBufferMetadata;
    RayBuffer_ref rayBuffer;
    RayPayloadBuffer_ref rayPayload;
};

void main()
{
    RayInfo rayInfoRead = RayInfo(
            RayBufferMetadata_ref(pc.data.read_rayBufferMetadataAddress),
            RayBuffer_ref(pc.data.read_rayBufferAddress),
            RayPayloadBuffer_ref(pc.data.read_rayPayloadAddress)
        );

    const u32 rayCount = rayInfoRead.rayBufferMetadata.data.rayCount;
    const u32 rayId = gl_GlobalInvocationID.x;
    if (rayId >= rayCount)
        return;

    u32 packedPixelPos = rayInfoRead.rayPayload.val[rayId].packedPosition;
    ivec2 pixelPos = ivec2(packedPixelPos >> 18, (packedPixelPos >> 4) & 0x3FFF);

    RayTraceResults_BV_ref results = RayTraceResults_BV_ref(pc.data.rayTraceResultAddress);
    RayTraceResult_BV result = results.result[rayId];
    Ray r = rayInfoRead.rayBuffer.ray[rayId];

    const vec3 clearColor = vec3(.3f);
    // const vec3 clearColor = vec3(.4285714f);
    vec3 throughput = rayInfoRead.rayPayload.val[rayId].throughput;
    vec3 radiance = vec3(0.f);
    vec3 accumulatedRadiance = vec3(0.f);
    if (pc.data.samplesComputed > 0)
        accumulatedRadiance = imageLoad(image, pixelPos).xyz;

    vec3 env = vec3(max(0.f, dot(r.d.xyz, pc.data.dirLight.xyz)));
    env *= pc.data.dirLight.w;

    // hit environment
    if (result.bvId == INVALID_ID) {
        if (pc.data.depth == 0)
            radiance = clearColor;
        else
            radiance = throughput * env;
        radiance = (pc.data.samplesComputed * accumulatedRadiance + radiance) / f32(pc.data.samplesComputed + 1);
        imageStore(image, pixelPos, vec4(radiance, 1.f));
        return;
    }
    if (pc.data.depth + 1 > pc.data.depthMax) {
        radiance = (pc.data.samplesComputed * accumulatedRadiance + radiance) / f32(pc.data.samplesComputed + 1);
        imageStore(image, pixelPos, vec4(radiance, 1.f));
        return;
    }

    const vec3 pos = r.o.xyz + r.d.xyz * result.t;
    vec3 nrm = result.normal;

    u32 seed = rayInfoRead.rayPayload.val[rayId].seed;
    // Lambert sample
    u32 seed_c = tea(result.bvId, 1);
    vec3 albedo = vec3(rnd(seed_c), rnd(seed_c), rnd(seed_c));

    if (result.tId != INVALID_ID) {
        GeometryDescriptor gDesc = GeometryDescriptor(pc.data.geometryDescriptorAddress);
        BvhTriangleIndices triangleIndices = BvhTriangleIndices(pc.data.bvhTriangleIndicesAddress);

        u32 instanceId = triangleIndices.val[result.tId].nodeId;
        u32 primitiveId = triangleIndices.val[result.tId].triangleId;

        Geometry g = gDesc.g[instanceId];
        uvec3_buf indices = uvec3_buf(g.idxAddress);
        const uvec3 idx = indices.val[primitiveId];

        vec3_buf normals = vec3_buf(g.normalAddress);
        const vec3 n0 = normals.val[idx.x];
        const vec3 n1 = normals.val[idx.y];
        const vec3 n2 = normals.val[idx.z];

        const vec3 barycentrics = vec3(0.33333f);

        nrm = n0 * barycentrics.x + n1 * barycentrics.y + n2 * barycentrics.z;
    }
    if (pc.data.depth == 0) {
        const vec3 c = camera.viewInv[3].xyz;
        const vec3 v = normalize(c - pos);
        if (dot(v, nrm) < 0.f)
            nrm = -nrm;
    }

    // const vec3 albedo = vec3(1.f);
    const vec3 newDirection = SampleHemisphereCosineWorldSpace(rnd(seed), rnd(seed), nrm);
    const f32 cosTheta = dot(newDirection, nrm);
    const vec3 f = albedo * M_PI_INV;
    const f32 pdf = cosTheta * M_PI_INV;

    throughput *= (f * cosTheta) / pdf;
    r.o = vec4(OffsetRay(pos, nrm), 1e-7f);
    r.d = vec4(newDirection, BIG_FLOAT);

    RayInfo rayInfoWrite = RayInfo(
            RayBufferMetadata_ref(pc.data.write_rayBufferMetadataAddress),
            RayBuffer_ref(pc.data.write_rayBufferAddress),
            RayPayloadBuffer_ref(pc.data.write_rayPayloadAddress)
        );

    const uvec4 ballot = subgroupBallot(true);
    u32 newRayId;
    if (subgroupElect()) {
        newRayId = atomicAdd(rayInfoWrite.rayBufferMetadata.data.rayCount, subgroupBallotBitCount(ballot));
    }
    newRayId = subgroupBroadcastFirst(newRayId) + subgroupBallotExclusiveBitCount(ballot);

    packedPixelPos = (packedPixelPos & ~0xfu) | RAY_TYPE_SECONDARY;
    rayInfoWrite.rayBuffer.ray[newRayId] = r;
    rayInfoWrite.rayPayload.val[newRayId].packedPosition = packedPixelPos;
    rayInfoWrite.rayPayload.val[newRayId].seed = seed;
    rayInfoWrite.rayPayload.val[newRayId].throughput = throughput;
}
