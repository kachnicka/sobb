#version 460

#extension GL_EXT_buffer_reference2: require
#extension GL_EXT_scalar_block_layout: require
#extension GL_GOOGLE_include_directive : enable

#extension GL_KHR_memory_scope_semantics : require
#extension GL_KHR_shader_subgroup_basic : require
#extension GL_KHR_shader_subgroup_ballot : require
#extension GL_KHR_shader_subgroup_arithmetic : require

#define INCLUDE_FROM_SHADER
#include "shared/types.glsl"
#include "shared/compute.glsl"
#include "shared/bv_aabb.glsl"
#include "shared/data_bvh.h"
#include "shared/data_plocpp.h"

layout(local_size_x_id = 0) in;
layout(constant_id = 1) const u32 sc_SubgroupSize = 32;

const u32 sc_SubgroupCount = gl_WorkGroupSize.x / sc_SubgroupSize;

layout(push_constant) uniform uPushConstant {
    PC_Collapse data;
} pc;

#define SCHEDULER_DATA_ADDRESS pc.data.schedulerDataAddress
#include "shared/task_scheduler.glsl"

shared u32 sharedPrefix;
shared u32 aggregatePerSubgroup[sc_SubgroupCount];

#define NODE_STATE_SUBTREE 69
#define NODE_STATE_LEAF 420
#define NODE_STATE_INVALID -1

void decideLeafOrInternal(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    if (nodeId >= pc.data.leafNodeCount)
        return;

    u32_buf counter = u32_buf(pc.data.counterAddress);
    u32_buf nodeState = u32_buf(pc.data.nodeStateAddress);
    u32_buf sahCost = u32_buf(pc.data.sahCostAddress);
    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);

    NodeBVH2_AABB node = bvh.node[nodeId];
    f32 nodeSurfaceArea = bvArea(node.bv);
    // input leaf node size is always 1
    sahCost.val[nodeId] = floatBitsToUint(nodeSurfaceArea * pc.data.c_i);
    nodeState.val[nodeId] = NODE_STATE_LEAF;

    nodeId = bvh.node[nodeId].parent;
    while (atomicAdd(counter.val[nodeId], 1) > 0) {
        node = bvh.node[nodeId];
        nodeSurfaceArea = bvArea(node.bv);

        f32 costAsSubtree = nodeSurfaceArea * pc.data.c_t;
        costAsSubtree += uintBitsToFloat(sahCost.val[node.c0 < 0 ? ~node.c0 : node.c0]);
        costAsSubtree += uintBitsToFloat(sahCost.val[node.c1 < 0 ? ~node.c1 : node.c1]);

        f32 costAsLeaf = BIG_FLOAT;
        if (abs(node.size) <= pc.data.maxLeafSize)
            costAsLeaf = nodeSurfaceArea * abs(node.size) * pc.data.c_i;

        if (costAsSubtree > costAsLeaf) {
            nodeState.val[nodeId] = NODE_STATE_LEAF;
            sahCost.val[nodeId] = floatBitsToUint(costAsLeaf);
        }
        else {
            nodeState.val[nodeId] = NODE_STATE_SUBTREE;
            sahCost.val[nodeId] = floatBitsToUint(costAsSubtree);
        }
        memoryBarrier(gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsAcquireRelease | gl_SemanticsMakeAvailable | gl_SemanticsMakeVisible);

        nodeId = node.parent;
        if (nodeId == INVALID_ID)
            return;
    }
}

void findCollapsedRoots(in u32 taskId)
{
    const u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    if (nodeId >= pc.data.leafNodeCount)
        return;

    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    u32_buf nodeState = u32_buf(pc.data.nodeStateAddress);
    u32_buf leafId = u32_buf(pc.data.leafNodeAddress);

    u32 leafNodeId = nodeId;
    u32 parentNodeId = bvh.node[nodeId].parent;
    u32 parentNodeState = nodeState.val[parentNodeId];

    while (true) {
        if (parentNodeState == NODE_STATE_LEAF)
            leafNodeId = parentNodeId;

        parentNodeId = bvh.node[parentNodeId].parent;
        if (parentNodeId == INVALID_ID)
            break;
        parentNodeState = nodeState.val[parentNodeId];
    }
    leafId.val[nodeId] = leafNodeId;
}

void invalidateCollapsedNodes(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    if (nodeId >= pc.data.leafNodeCount)
        return;

    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    u32_buf counter = u32_buf(pc.data.counterAddress);
    u32_buf nodeState = u32_buf(pc.data.nodeStateAddress);
    u32_buf leafId = u32_buf(pc.data.leafNodeAddress);

    u32 leafNodeId = leafId.val[nodeId];
    if (nodeId == leafNodeId)
        return;
    nodeState.val[nodeId] = NODE_STATE_INVALID;

    nodeId = bvh.node[nodeId].parent;
    while (atomicAdd(counter.val[nodeId], 1) > 0) {
        if (nodeId == leafNodeId)
            return;
        nodeState.val[nodeId] = NODE_STATE_INVALID;

        memoryBarrier(gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsAcquireRelease | gl_SemanticsMakeAvailable | gl_SemanticsMakeVisible);
        nodeId = bvh.node[nodeId].parent;
        if (nodeId == INVALID_ID)
            return;
    }
}

void computeNewNodeIds(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
    if (nodeId >= totalNodeCount)
        return;

    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    u32_buf nodeCounts = u32_buf(pc.data.collapsedTreeNodeCountsAddress);
    u32_buf nodeState = u32_buf(pc.data.nodeStateAddress);
    u32_buf nodeNewId = u32_buf(pc.data.newNodeIdAddress);

    u32 myState = nodeState.val[nodeId];
    u32 myNewOffset = 0;

    const u32 rootId = totalNodeCount - 1;

    u32 offset = 0;
    uvec4 ballot = subgroupBallot(myState == NODE_STATE_SUBTREE && nodeId != rootId);
    if (subgroupElect())
        offset = atomicAdd(nodeCounts.val[0], subgroupBallotBitCount(ballot));
    offset = subgroupBroadcastFirst(offset) + subgroupBallotExclusiveBitCount(ballot);
    if (myState == NODE_STATE_SUBTREE)
        myNewOffset = offset;

    ballot = subgroupBallot(myState == NODE_STATE_LEAF);
    if (subgroupElect())
        offset = atomicAdd(nodeCounts.val[1], subgroupBallotBitCount(ballot));
    offset = subgroupBroadcastFirst(offset) + subgroupBallotExclusiveBitCount(ballot);
    if (myState == NODE_STATE_LEAF)
        myNewOffset = offset;

    // root id is set during the collapse() func
    if (nodeId == rootId)
        myNewOffset = INVALID_ID;

    nodeNewId.val[nodeId] = myNewOffset;
}

void computeNewTriangleOffsets(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
    if (nodeId >= totalNodeCount)
        return;

    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    u32_buf counter = u32_buf(pc.data.counterAddress);
    u32_buf nodeState = u32_buf(pc.data.nodeStateAddress);
    u32_buf newTriOffset = u32_buf(pc.data.newTriIdAddress);

    u32 myState = nodeState.val[nodeId];
    u32 mySize = 0;
    if (myState == NODE_STATE_LEAF)
        mySize = abs(bvh.node[nodeId].size);

    // init DL data
    if (gl_LocalInvocationID.x == 0)
        sharedPrefix = 0;
    if (gl_LocalInvocationID.x < sc_SubgroupSize)
        aggregatePerSubgroup[gl_LocalInvocationID.x] = 0;
    barrier();

    u32 inclusiveSum = subgroupInclusiveAdd(mySize);
    if (gl_SubgroupInvocationID == (sc_SubgroupSize - 1))
        aggregatePerSubgroup[gl_SubgroupID] = inclusiveSum;
    barrier();

    u32 total = 0;
    if (gl_SubgroupID == 0) {
        u32 mySubgroupAggregate = aggregatePerSubgroup[gl_SubgroupInvocationID];
        total = subgroupInclusiveAdd(mySubgroupAggregate);
        // store exclusive sum
        aggregatePerSubgroup[gl_SubgroupInvocationID] = total - mySubgroupAggregate;
        // store total aggregate for this workgroup
        if (gl_SubgroupInvocationID == (sc_SubgroupSize - 1))
            sharedPrefix = atomicAdd(counter.val[2], total);
    }
    barrier();

    if (myState == NODE_STATE_LEAF)
        newTriOffset.val[nodeId] = sharedPrefix + aggregatePerSubgroup[gl_SubgroupID] + inclusiveSum - mySize;
}

void collapse(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
    if (nodeId >= totalNodeCount)
        return;

    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    BVH2_AABB bvhCollapsed = BVH2_AABB(pc.data.bvhCollapsedAddress);
    i32_buf nodeCounts = i32_buf(pc.data.collapsedTreeNodeCountsAddress);
    u32_buf nodeState = u32_buf(pc.data.nodeStateAddress);
    i32_buf nodeIdNew = i32_buf(pc.data.newNodeIdAddress);
    i32_buf triOffsetNew = i32_buf(pc.data.newTriIdAddress);

    const i32 numberOfLeaves = nodeCounts.val[1];

    u32 myState = nodeState.val[nodeId];
    if (myState == NODE_STATE_INVALID)
        return;

    i32 newNodeId = nodeIdNew.val[nodeId];
    // unresolved root remap to keep root on defined (last) position
    if (nodeId == (totalNodeCount - 1))
        newNodeId = nodeCounts.val[0];

    if (myState == NODE_STATE_SUBTREE)
        newNodeId += numberOfLeaves;

    NodeBVH2_AABB node = bvh.node[nodeId];
    if (node.parent != INVALID_ID) {
        i32 newParentOffset = nodeIdNew.val[node.parent];
        if (newParentOffset == INVALID_ID)
            newParentOffset = nodeCounts.val[0];

        node.parent = newParentOffset + numberOfLeaves;
    }

    if (myState == NODE_STATE_LEAF) {
        node.c0 = triOffsetNew.val[nodeId];
        node.c1 = node.c0 + abs(node.size);
        node.size = -node.size;
    }
    else {
        if (node.c0 < 0) node.c0 = ~node.c0;
        if (node.c1 < 0) node.c1 = ~node.c1;
        node.c0 = (nodeState.val[node.c0] == NODE_STATE_LEAF) ? ~nodeIdNew.val[node.c0] : nodeIdNew.val[node.c0] + numberOfLeaves;
        node.c1 = (nodeState.val[node.c1] == NODE_STATE_LEAF) ? ~nodeIdNew.val[node.c1] : nodeIdNew.val[node.c1] + numberOfLeaves;
    }

    bvhCollapsed.node[newNodeId] = node;
}

void copyTriangles(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    if (nodeId >= pc.data.leafNodeCount)
        return;

    u32_buf leafId = u32_buf(pc.data.leafNodeAddress);
    u32_buf triOffsetNew = u32_buf(pc.data.newTriIdAddress);
    BvhTriangles bvhTriangles = BvhTriangles(pc.data.bvhTrianglesAddress);
    BvhTriangles bvhCollapsedTriangles = BvhTriangles(pc.data.bvhCollapsedTrianglesAddress);
    BvhTriangleIndices bvhTriangleIndices = BvhTriangleIndices(pc.data.bvhTriangleIndicesAddress);
    BvhTriangleIndices bvhCollapsedTriangleIndices = BvhTriangleIndices(pc.data.bvhCollapsedTriangleIndicesAddress);

    u32 leafNodeId = leafId.val[nodeId];
    u32 myTriOffset = atomicAdd(triOffsetNew.val[leafNodeId], 1);
    bvhCollapsedTriangles.t[myTriOffset] = bvhTriangles.t[nodeId];
    bvhCollapsedTriangleIndices.val[myTriOffset] = bvhTriangleIndices.val[nodeId];
}

void fResetCounter(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
    if (nodeId >= totalNodeCount)
        return;

    u32_buf counter = u32_buf(pc.data.counterAddress);
    counter.val[nodeId] = 0;
}

#define COLLAPSING_1_LEAF_OR_INTERNAL 0
#define COLLAPSING_1_RESET_COUNTER 1
#define COLLAPSING_2_SUBTREE_ROOTS 2
#define COLLAPSING_2_RESET_COUNTER 3
#define COLLAPSING_3_INVALIDATE_SUBTREES 4
#define COLLAPSING_3_RESET_COUNTER 5
#define COLLAPSING_4_REMAP_IDS 6
#define COLLAPSING_4_RESET_COUNTER 7
#define COLLAPSING_5_TRIANGLE_OFFSETS 8
#define COLLAPSING_6_COLLAPSE_BVH 9
#define COLLAPSING_7_COPY_TRI_INDICES 10
#define COLLAPSING_DONE 11

void main()
{
    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    BVH2_AABB bvhCollapsed = BVH2_AABB(pc.data.bvhCollapsedAddress);

    if (gl_GlobalInvocationID.x == 0) {
        i32_buf nodeCounts = i32_buf(pc.data.collapsedTreeNodeCountsAddress);
        nodeCounts.val[0] = 0;
        nodeCounts.val[1] = 0;

        allocTasks(gl_NumWorkGroups.x, COLLAPSING_1_LEAF_OR_INTERNAL);
    }

    while (true) {
        Task task = beginTask(gl_LocalInvocationID.x);

        switch (task.phase) {
            case COLLAPSING_1_LEAF_OR_INTERNAL:
            decideLeafOrInternal(task.id);

            if (endTask(gl_LocalInvocationID.x)) {
                u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
                u32 newTaskCount = divCeil(totalNodeCount, gl_WorkGroupSize.x);
                allocTasks(newTaskCount, COLLAPSING_1_RESET_COUNTER);
            }
            break;
            case COLLAPSING_1_RESET_COUNTER:
            fResetCounter(task.id);

            if (endTask(gl_LocalInvocationID.x))
                allocTasks(gl_NumWorkGroups.x, COLLAPSING_2_SUBTREE_ROOTS);
            break;
            case COLLAPSING_2_SUBTREE_ROOTS:
            findCollapsedRoots(task.id);

            if (endTask(gl_LocalInvocationID.x))
                allocTasks(gl_NumWorkGroups.x, COLLAPSING_3_INVALIDATE_SUBTREES);
            break;
            case COLLAPSING_3_INVALIDATE_SUBTREES:
            invalidateCollapsedNodes(task.id);

            if (endTask(gl_LocalInvocationID.x)) {
                u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
                u32 newTaskCount = divCeil(totalNodeCount, gl_WorkGroupSize.x);
                allocTasks(newTaskCount, COLLAPSING_4_REMAP_IDS);
            }
            break;
            case COLLAPSING_4_REMAP_IDS:
            computeNewNodeIds(task.id);

            if (endTask(gl_LocalInvocationID.x)) {
                u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
                u32 newTaskCount = divCeil(totalNodeCount, gl_WorkGroupSize.x);
                allocTasks(newTaskCount, COLLAPSING_5_TRIANGLE_OFFSETS);
            }
            break;
            case COLLAPSING_5_TRIANGLE_OFFSETS:
            computeNewTriangleOffsets(task.id);

            if (endTask(gl_LocalInvocationID.x)) {
                u32 totalNodeCount = 2 * pc.data.leafNodeCount - 1;
                u32 newTaskCount = divCeil(totalNodeCount, gl_WorkGroupSize.x);
                allocTasks(newTaskCount, COLLAPSING_6_COLLAPSE_BVH);
            }
            break;
            case COLLAPSING_6_COLLAPSE_BVH:
            collapse(task.id);

            if (endTask(gl_LocalInvocationID.x))
                allocTasks(gl_NumWorkGroups.x, COLLAPSING_7_COPY_TRI_INDICES);
            break;
            case COLLAPSING_7_COPY_TRI_INDICES:
            copyTriangles(task.id);

            if (endTask(gl_LocalInvocationID.x)) {
                // store dispatch data for processing the collapsed bvh
                u32_buf nodeCounts = u32_buf(pc.data.collapsedTreeNodeCountsAddress);

                allocTasks(gl_NumWorkGroups.x, COLLAPSING_DONE);
            }
            break;
            case COLLAPSING_DONE:
            return;
        }
    }
    ;
}
