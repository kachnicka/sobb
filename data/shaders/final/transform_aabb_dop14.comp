#version 460

#extension GL_EXT_buffer_reference2: require
#extension GL_EXT_scalar_block_layout: require
#extension GL_KHR_memory_scope_semantics : require
#extension GL_GOOGLE_include_directive : enable

#define DOP_14
#define INCLUDE_FROM_SHADER
#include "shared/types.glsl"
#include "shared/compute.glsl"
#include "shared/bv_aabb.glsl"
#include "shared/bv_dop.glsl"
#include "shared/data_bvh.h"
#include "shared/data_plocpp.h"
#include "shared/data_scene.h"

layout(local_size_x_id = 0) in;

layout(push_constant) uniform uPushConstant {
    PC_TransformToDOP data;
} pc;

void transform(in u32 taskId)
{
    u32 nodeId = taskId * gl_WorkGroupSize.x + gl_LocalInvocationID.x;
    if (nodeId >= pc.data.leafNodeCount)
        return;

    BVH2_AABB bvh = BVH2_AABB(pc.data.bvhAddress);
    BvhTriangleIndices triangleIndices = BvhTriangleIndices(pc.data.bvhTriangleIndicesAddress);
    u32_buf counter = u32_buf(pc.data.countersAddress);
    GeometryDescriptor gDesc = GeometryDescriptor(pc.data.geometryDescriptorAddress);

    BVH2_DOP14 bvhDOP = BVH2_DOP14(pc.data.bvhDOPAddress);

    NodeBVH2_AABB node = bvh.node[nodeId];
    bvhDOP.node[nodeId].size = node.size;
    bvhDOP.node[nodeId].parent = node.parent;
    bvhDOP.node[nodeId].c0 = node.c0;
    bvhDOP.node[nodeId].c1 = node.c1;

    DOP dop;
    {
        i32 triStartId = node.c0;
        i32 triCount = abs(node.size) - 1;
        // init the dop with the first triangle, increment the triangle index
        {
            BvhTriangleIndex ids = triangleIndices.val[triStartId++];
            Geometry g = gDesc.g[ids.nodeId];
            uvec3_buf indices = uvec3_buf(g.idxAddress);
            vec3_buf vertices = vec3_buf(g.vtxAddress);

            const uvec3 idx = indices.val[ids.triangleId];
            dop = dopInit(vertices.val[idx.x], vertices.val[idx.y], vertices.val[idx.z]);
        }
        // fit the rest of the triangles
        for (i32 triId = triStartId; triId < triStartId + triCount; triId++) {
            BvhTriangleIndex ids = triangleIndices.val[triId];
            Geometry g = gDesc.g[ids.nodeId];
            uvec3_buf indices = uvec3_buf(g.idxAddress);
            vec3_buf vertices = vec3_buf(g.vtxAddress);

            const uvec3 idx = indices.val[ids.triangleId];
            bvFit(dop, vertices.val[idx.x], vertices.val[idx.y], vertices.val[idx.z]);
        }
    }

    bvhDOP.node[nodeId].bv = dop;

    i32 cId = ~(i32(nodeId));
    nodeId = node.parent;
    while (atomicAdd(counter.val[nodeId], 1) > 0)
    {
        node = bvh.node[nodeId];
        bvhDOP.node[nodeId].size = node.size;
        bvhDOP.node[nodeId].parent = node.parent;
        bvhDOP.node[nodeId].c0 = node.c0;
        bvhDOP.node[nodeId].c1 = node.c1;

        i32 nodeIdToLoad = (cId == node.c0) ? node.c1 : node.c0;
        if (nodeIdToLoad < 0)
            nodeIdToLoad = ~nodeIdToLoad;

        DOP cDop = bvhDOP.node[nodeIdToLoad].bv;
        bvFit(dop, cDop);
        bvhDOP.node[nodeId].bv = dop;

        memoryBarrier(gl_ScopeQueueFamily, gl_StorageSemanticsBuffer, gl_SemanticsAcquireRelease | gl_SemanticsMakeAvailable | gl_SemanticsMakeVisible);

        cId = i32(nodeId);
        nodeId = node.parent;
        if (nodeId == INVALID_ID)
            return;
    }
}

void main()
{
    transform(gl_WorkGroupID.x);
}
