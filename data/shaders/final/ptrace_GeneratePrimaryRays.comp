#version 460

#extension GL_EXT_buffer_reference2: require
#extension GL_EXT_scalar_block_layout: require
#extension GL_GOOGLE_include_directive : enable

#define INCLUDE_FROM_SHADER
#include "shared/types.glsl"
#include "shared/random.glsl"
#include "shared/compute.glsl"
#include "shared/data_ptrace.h"

layout(local_size_x_id = 0, local_size_y_id = 1) in;

layout(set = 0, binding = 0, rgba32f) uniform image2D image;
layout(set = 0, binding = 1) uniform Camera {
    mat4 view;
    mat4 projection;
    mat4 viewInv;
    mat4 projectionInv;
} camera;

layout(push_constant, scalar) uniform uPushConstant
{
    PC_GenPrimary data;
} pc;

void main()
{
    const ivec2 imgSize = imageSize(image);
    const ivec2 imgCoords = ivec2(gl_GlobalInvocationID.xy);

    if (imgCoords.x >= imgSize.x || imgCoords.y >= imgSize.y)
        return;

    uint seed = tea(imgCoords.y * imgSize.x + imgCoords.x, pc.data.samplesComputed);
    const uint sampleId = pc.data.samplesComputed;
    const vec2 subpixelJitter = sampleId == 0 ? vec2(.5f) : vec2(rnd(seed), rnd(seed));
    const vec2 pixelCenter = vec2(imgCoords) + subpixelJitter;
    const vec2 inUV = pixelCenter / vec2(imgSize.xy);
    const vec2 d = inUV * 2.f - 1.f;
    const vec4 target = camera.projectionInv * vec4(d.x, d.y, 1.f, 1.f);

    Ray ray;
    ray.o = camera.viewInv * vec4(0.f, 0.f, 0.f, 1.f);
    ray.d = camera.viewInv * vec4(normalize(target.xyz), 0.f);
    ray.o.w = .01f;
    ray.d.w = BIG_FLOAT;

    // maintaining a per tile ray coherence, likely can be improved by a Morton curve
    const uvec2 tileId = gl_WorkGroupID.xy;
    const uint tileX = min(gl_WorkGroupSize.x, imgSize.x - tileId.x * gl_WorkGroupSize.x);
    const uint tileY = min(gl_WorkGroupSize.y, imgSize.y - tileId.y * gl_WorkGroupSize.y);
    const uint rowOffset = tileId.y * gl_WorkGroupSize.y * imgSize.x;
    const uint colOffset = tileId.x * gl_WorkGroupSize.x * tileY;
    // const uint localOffset = gl_LocalInvocationID.y * tileX + gl_LocalInvocationID.x;
    const uint localOffset = gl_LocalInvocationID.x * tileY + gl_LocalInvocationID.y;
    const uint rayBufferOffset = rowOffset + colOffset + localOffset;

    RayBuffer_ref rayBuffer = RayBuffer_ref(pc.data.rayBufferAddress);
    RayPayloadBuffer_ref rayPayload = RayPayloadBuffer_ref(pc.data.rayPayloadAddress);
    rayBuffer.ray[rayBufferOffset] = ray;
    rayPayload.val[rayBufferOffset].packedPosition = imgCoords.x << 18 | imgCoords.y << 4 | RAY_TYPE_PRIMARY;
    rayPayload.val[rayBufferOffset].seed = seed;
    rayPayload.val[rayBufferOffset].throughput = vec3(1.f);

    if (gl_GlobalInvocationID.x == 0 && gl_GlobalInvocationID.y == 0) {
        RayBufferMetadata_ref rayBufMeta = RayBufferMetadata_ref(pc.data.rayBufferMetadataAddress);
        rayBufMeta.data.rayCount = imgSize.x * imgSize.y;
        rayBufMeta.data.rayTracedCount = 0;
    }
}
